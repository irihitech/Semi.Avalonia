{
  "version": 3,
  "sources": ["../webapp/modules/sw.ts"],
  "sourcesContent": ["const WRITE = 0;\r\nconst PULL = 0;\r\nconst ERROR = 1;\r\nconst ABORT = 1;\r\nconst CLOSE = 2;\r\n\r\nclass MessagePortSource implements UnderlyingSource {\r\n    private controller?: ReadableStreamController<any>;\r\n\r\n    constructor (private readonly port: MessagePort) {\r\n        this.port.onmessage = evt => this.onMessage(evt.data);\r\n    }\r\n\r\n    start (controller: ReadableStreamController<any>) {\r\n        this.controller = controller;\r\n    }\r\n\r\n    cancel (reason: Error) {\r\n    // Firefox can notify a cancel event, chrome can't\r\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=638494\r\n        this.port.postMessage({ type: ERROR, reason: reason.message });\r\n        this.port.close();\r\n    }\r\n\r\n    onMessage (message: { type: number; chunk: Uint8Array; reason: any }) {\r\n    // enqueue() will call pull() if needed when there's no backpressure\r\n        if (!this.controller) {\r\n            return;\r\n        }\r\n        if (message.type === WRITE) {\r\n            this.controller.enqueue(message.chunk);\r\n            this.port.postMessage({ type: PULL });\r\n        }\r\n        if (message.type === ABORT) {\r\n            this.controller.error(message.reason);\r\n            this.port.close();\r\n        }\r\n        if (message.type === CLOSE) {\r\n            this.controller.close();\r\n            this.port.close();\r\n        }\r\n    }\r\n}\r\n\r\nself.addEventListener(\"install\", () => {\r\n    (self as any).skipWaiting();\r\n});\r\n\r\nself.addEventListener(\"activate\", event /* ExtendableEvent */ => {\r\n    (event as any).waitUntil((self as any).clients.claim());\r\n});\r\n\r\n(self as any).map = new Map();\r\n\r\n// This should be called once per download\r\n// Each event has a dataChannel that the data will be piped through\r\nglobalThis.addEventListener(\"message\", evt => {\r\n    const data = evt.data;\r\n    if (data.url && data.readablePort) {\r\n        data.rs = new ReadableStream(\r\n            new MessagePortSource(evt.data.readablePort),\r\n            new CountQueuingStrategy({ highWaterMark: 4 })\r\n        );\r\n        const map = (self as any).map;\r\n        map.set(data.url, data);\r\n    }\r\n});\r\n\r\nglobalThis.addEventListener(\"fetch\", evt => {\r\n    const url = (evt as any).request.url;\r\n    const map = (self as any).map;\r\n    const data = map.get(url);\r\n    if (!data) return null;\r\n    map.delete(url);\r\n    (evt as any).respondWith(new Response(data.rs, {\r\n        headers: data.headers\r\n    }));\r\n});\r\n\r\nexport {};\r\n"],
  "mappings": "AAMA,IAAMA,EAAN,KAAoD,CAGhD,YAA8BC,EAAmB,CAAnB,UAAAA,EAC1B,KAAK,KAAK,UAAYC,GAAO,KAAK,UAAUA,EAAI,IAAI,CACxD,CAEA,MAAOC,EAA2C,CAC9C,KAAK,WAAaA,CACtB,CAEA,OAAQC,EAAe,CAGnB,KAAK,KAAK,YAAY,CAAE,KAAM,EAAO,OAAQA,EAAO,OAAQ,CAAC,EAC7D,KAAK,KAAK,MAAM,CACpB,CAEA,UAAWC,EAA2D,CAE9D,CAAC,KAAK,aAGNA,EAAQ,OAAS,IACjB,KAAK,WAAW,QAAQA,EAAQ,KAAK,EACrC,KAAK,KAAK,YAAY,CAAE,KAAM,CAAK,CAAC,GAEpCA,EAAQ,OAAS,IACjB,KAAK,WAAW,MAAMA,EAAQ,MAAM,EACpC,KAAK,KAAK,MAAM,GAEhBA,EAAQ,OAAS,IACjB,KAAK,WAAW,MAAM,EACtB,KAAK,KAAK,MAAM,GAExB,CACJ,EAEA,KAAK,iBAAiB,UAAW,IAAM,CAClC,KAAa,YAAY,CAC9B,CAAC,EAED,KAAK,iBAAiB,WAAYC,GAA+B,CAC5DA,EAAc,UAAW,KAAa,QAAQ,MAAM,CAAC,CAC1D,CAAC,EAEA,KAAa,IAAM,IAAI,IAIxB,WAAW,iBAAiB,UAAWJ,GAAO,CAC1C,IAAMK,EAAOL,EAAI,KACbK,EAAK,KAAOA,EAAK,eACjBA,EAAK,GAAK,IAAI,eACV,IAAIP,EAAkBE,EAAI,KAAK,YAAY,EAC3C,IAAI,qBAAqB,CAAE,cAAe,CAAE,CAAC,CACjD,EACa,KAAa,IACtB,IAAIK,EAAK,IAAKA,CAAI,EAE9B,CAAC,EAED,WAAW,iBAAiB,QAASL,GAAO,CACxC,IAAMM,EAAON,EAAY,QAAQ,IAC3BO,EAAO,KAAa,IACpBF,EAAOE,EAAI,IAAID,CAAG,EACxB,GAAI,CAACD,EAAM,OAAO,KAClBE,EAAI,OAAOD,CAAG,EACbN,EAAY,YAAY,IAAI,SAASK,EAAK,GAAI,CAC3C,QAASA,EAAK,OAClB,CAAC,CAAC,CACN,CAAC",
  "names": ["MessagePortSource", "port", "evt", "controller", "reason", "message", "event", "data", "url", "map"]
}
